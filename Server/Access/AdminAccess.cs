using Microsoft.EntityFrameworkCore;
using MyVidious.Background;
using MyVidious.Data;
using MyVidious.Models.Admin;
using MyVidious.Utilities;
using Quartz;

namespace MyVidious.Access;

public class AdminAccess
{
    private VideoDbContext _videoDbContext;
    private InvidiousAPIAccess _invidiousApiAccess;
    private MeilisearchAccess _meilisearchAccess;
    private ISchedulerFactory _schedulerFactory;
    private GlobalCache _globalCache;
    private AlgorithmAccess _algorithmAccess;

    public AdminAccess(
        VideoDbContext videoDbContext,
        InvidiousAPIAccess invidiousApiAccess,
        MeilisearchAccess meilisearchAccess,
        AlgorithmAccess algorithmAccess,
        ISchedulerFactory schedulerFactory,
        GlobalCache globalCache
        )
    {
        _videoDbContext = videoDbContext;
        _invidiousApiAccess = invidiousApiAccess;
        _meilisearchAccess = meilisearchAccess;
        _schedulerFactory = schedulerFactory;
        _globalCache = globalCache;
        _algorithmAccess = algorithmAccess;
    }

    public async Task<IEnumerable<FoundChannel>> SearchChannels(string searchText)
    {
        if (searchText == null || searchText.Length < 2)
        {
            throw new WebRequestException(400, "searchText must be at least length 2");
        }
        var invidiousResults = await _invidiousApiAccess.Search(new Models.Invidious.SearchRequest
        {
            Q = searchText,
            Type = "channel",
        });
        var invidiousChannels = invidiousResults.OfType<Models.Invidious.SearchResponse_Channel>().Take(10).ToList();
        var uniqueIds = invidiousChannels.Select(z => z.AuthorId).ToList();
        if (!uniqueIds.Any())
        {
            return Enumerable.Empty<FoundChannel>();
        }
        var existingChannels = await _videoDbContext.Channels.Where(z => uniqueIds.Contains(z.UniqueId)).ToListAsync();
        var response = invidiousChannels.Select(invidiousChannel =>
        {
            var existingChannel = existingChannels.FirstOrDefault(z => z.UniqueId == invidiousChannel.AuthorId);
            var thumbnail = invidiousChannel.AuthorThumbnails?.Any(z => z.Height > 64) ?? false
                ? invidiousChannel.AuthorThumbnails.OrderBy(z => z.Height).First().Url
                : invidiousChannel.AuthorThumbnails?.OrderByDescending(z => z.Height).FirstOrDefault()?.Url;
            if (thumbnail != null && thumbnail.StartsWith("//"))
            {
                thumbnail = "https:" + thumbnail;
            }
            return new FoundChannel
            {
                ChannelId = existingChannel?.Id,
                ThumbnailUrl = thumbnail,

                Type = invidiousChannel.Type,
                ChannelHandle = invidiousChannel.ChannelHandle,
                Description = invidiousChannel.Description,
                DescriptionHtml = invidiousChannel.DescriptionHtml,
                Author = invidiousChannel.Author,
                AuthorId = invidiousChannel.AuthorId,
                AuthorUrl = invidiousChannel.AuthorUrl,
                AuthorThumbnails = invidiousChannel.AuthorThumbnails,
                AuthorVerified = invidiousChannel.AuthorVerified,
                AutoGenerated = invidiousChannel.AutoGenerated,
                SubCount = invidiousChannel.SubCount,
                VideoCount = existingChannel?.VideoCount ?? invidiousChannel.VideoCount, 
            };
        });
        return response;
    }

    public async Task<IEnumerable<FoundPlaylist>> SearchPlaylists(string searchText)
    {
        if (searchText == null || searchText.Length < 2)
        {
            throw new WebRequestException(400, "searchText must be at least length 2");
        }
        var invidiousResults = await _invidiousApiAccess.Search(new Models.Invidious.SearchRequest
        {
            Q = searchText,
            Type = "playlist",
        });
        var invidiousPlaylists = invidiousResults.OfType<Models.Invidious.SearchResponse_Playlist>().Take(10).ToList();
        var uniqueIds = invidiousPlaylists.Select(z => z.PlaylistId).ToList();
        if (!uniqueIds.Any())
        {
            return Enumerable.Empty<FoundPlaylist>();
        }
        var existingPlaylists = await _videoDbContext.Playlists.Where(z => uniqueIds.Contains(z.UniqueId)).ToListAsync();
        var response = invidiousPlaylists.Select(invidiousPlaylist =>
        {
            var existingPlaylist = existingPlaylists.FirstOrDefault(z => z.UniqueId == invidiousPlaylist.PlaylistId);
            var thumbnail = invidiousPlaylist.PlaylistThumbnail;
            if (thumbnail != null && thumbnail.StartsWith("//"))
            {
                thumbnail = "https:" + thumbnail;
            }
            return new FoundPlaylist
            {
                MyvidiousPlaylistId = existingPlaylist?.Id,
                ThumbnailUrl = thumbnail,

                Type = invidiousPlaylist.Type,
                Title = invidiousPlaylist.Title,
                PlaylistId = invidiousPlaylist.PlaylistId,
                PlaylistThumbnail = invidiousPlaylist.PlaylistThumbnail,
                Author = invidiousPlaylist.Author,
                AuthorId = invidiousPlaylist.AuthorId,
                AuthorUrl = invidiousPlaylist.AuthorUrl,
                AuthorVerified = invidiousPlaylist.AuthorVerified,
                VideoCount = invidiousPlaylist.VideoCount
            };
        });
        return response;
    }

    public async Task<IEnumerable<FoundAlgorithm>> SearchAlgorithms(string username, bool searchingOwn)
    {
        var algorithmsQuery = _videoDbContext.Algorithms.AsQueryable();
        if (searchingOwn)
        {
            algorithmsQuery = algorithmsQuery.Where(z => z.Username.ToLower() == username.ToLower());
        } else
        {
            algorithmsQuery = algorithmsQuery.Where(z => z.Username.ToLower() != username.ToLower() && z.IsListed);
        }
        var algorithms = await algorithmsQuery.ToListAsync();

        return algorithms.Select(z => new FoundAlgorithm
        {
            AlgorithmId = z.Id,
            AlgorithmName = z.Name,
            Description = z.Description,
            Username = z.Username
        });
    }

    private const int EST_VIDEO_COUNT = 100;

    public async Task<LoadAlgorithmResult> GetAlgorithm(int algorithmId)
    {
        var algorithmEntity = _videoDbContext.Algorithms.FirstOrDefault(z => z.Id == algorithmId);
        if (algorithmEntity == null)
        {
            throw new WebRequestException(400, $"algorithmId {algorithmId} not found");
        }
        var itemInfos = await _videoDbContext.GetAlgorithmItemInfos().Where(z => z.AlgorithmId == algorithmId).ToListAsync();
        var sumWeight = itemInfos.Sum(z => Math.Min(z.MaxItemWeight, z.VideoCount) * Math.Max(z.WeightMultiplier, 0));
        var result = new LoadAlgorithmResult
        {
            AlgorithmId = algorithmId,
            AlgorithmItems = itemInfos.Select(z => new LoadAlgorithmItem
            {
                PlaylistId = z.PlaylistId,
                ChannelId = z.ChannelId,
                WeightMultiplier = z.WeightMultiplier,
                Folder = z.Folder,
                Name = z.Name,
                VideoCount = z.VideoCount,
                UniqueId = z.UniqueId,
                FailureCount = z.FailureCount,
                EstimatedWeight = Math.Min(z.MaxItemWeight, z.VideoCount) * Math.Max(z.WeightMultiplier, 0)
            }),
            AlgorithmName = algorithmEntity.Name,
            Description = algorithmEntity.Description,
            MaxItemWeight = algorithmEntity.MaxItemWeight,
            Username = algorithmEntity.Username,
            EstimatedSumWeight = sumWeight,
        };
        return result;
    }

    public async Task<int> UpdateAlgorithm(UpdateAlgorithmRequest request, string username)
    {
        //to start, do a bunch of validation
        if (!request.Name.All(char.IsLetterOrDigit))
        {
            throw new WebRequestException(400, "Algorithm name must be alphanumeric");
        }
        var just1NonNull = request.AlgorithmItems.All(item => new object?[] { item.ChannelId, item.PlaylistId, item.NewChannel, item.NewPlaylist }.Count(p => p != null) == 1);
        if (!just1NonNull)
        {
            throw new WebRequestException(400, "each algorithmItem should have precisely 1 of the 4 nullable properties be non-null");
        }
        var newChannels = request.AlgorithmItems.Where(z => z.NewChannel != null).Select(z => z.NewChannel!);
        var duplicateChannel = newChannels.GroupBy(z => z.AuthorId).FirstOrDefault(z => z.Count() > 1);
        if (duplicateChannel != null)
        {
            throw new WebRequestException(400, "New Channels contains duplicates: " + string.Join(',', duplicateChannel.Select(z => z.Author)));
        }

        var newPlaylists = request.AlgorithmItems.Where(z => z.NewPlaylist != null).Select(z => z.NewPlaylist!);
        var duplicatePlaylist = newPlaylists.GroupBy(z => z.PlaylistId).FirstOrDefault(z => z.Count() > 1);
        if (duplicatePlaylist != null)
        {
            throw new WebRequestException(400, "New Playlists contains duplicates: " + string.Join(',', duplicatePlaylist.Select(z => z.Title)));
        }

        var algorithm = request.AlgorithmId.HasValue
            ? _videoDbContext.Algorithms.Include(z => z.AlgorithmItems).First(z => z.Id == request.AlgorithmId)
            : new AlgorithmEntity()
            {
                Name = request.Name,
                Username = username,
                IsRestricted = false,
                BiasCurrentPlaylist = 1,
                BiasCurrentChannel = 5,
            };
        if (algorithm.Username.ToLower() != username.ToLower())
        {
            throw new WebRequestException(400, "Algorithm belongs to a different user");
        }
        if (!request.AlgorithmId.HasValue || algorithm.Name?.ToLower() != request.Name.ToLower())
        {
            var nameConflicts = _videoDbContext.Algorithms.Where(z => z.Name.ToLower() == request.Name.ToLower() && z.Username.ToLower() == username.ToLower()).Any();
            if (nameConflicts)
            {
                throw new WebRequestException(400, $"user {username} already has an Algorithm named {request.Name}");
            }
        }

        //insert the new channels and trigger the job
        var newChannelEntities = new List<ChannelEntity>();
        if (newChannels.Any())
        {
            //save all new channels to the database
            newChannelEntities = newChannels.Select(newChannel =>
            {
                var thumbnailsJson = System.Text.Json.JsonSerializer.Serialize(newChannel.AuthorThumbnails);
                return new ChannelEntity
                {
                    Name = newChannel!.Author,
                    UniqueId = newChannel!.AuthorId,
                    Handle = newChannel.ChannelHandle,

                    Description = newChannel.Description,
                    AuthorUrl = newChannel.AuthorUrl,
                    ThumbnailsJson = thumbnailsJson,
                    AuthorVerified = newChannel.AuthorVerified,
                    AutoGenerated = newChannel.AutoGenerated,
                    SubCount = newChannel.SubCount,
                    VideoCount = 0,//I want this to represent the number of videos we have tracked, not the number of videos allegedly on the channel

                    AddedByUser = username,
                    DateLastScraped = null,
                    ScrapedToOldest = false,
                    ScrapeFailureCount = 0
                };
            }).ToList();
            _videoDbContext.Channels.AddRange(newChannelEntities);
            _videoDbContext.SaveChanges();//this should assign Ids to newChannelEntities
            await _meilisearchAccess.AddItems(newChannelEntities.Select(z => new MeilisearchItem
            {
                ChannelId = z.Id,
                FilterChannelId = z.Id,
                Name = z.Name,
                SecondName = z.Handle
            }));
            var scheduler = await _schedulerFactory.GetScheduler();
            await scheduler.TriggerJob(JobKey.Create(nameof(ChannelVideoJob)));
        }

        //insert the new playlist and trigger the job
        var newPlaylistEntities = new List<PlaylistEntity>();
        if (newPlaylists.Any())
        {
            //save all new channels to the database
            newPlaylistEntities = newPlaylists.Select(newPlaylist =>
            {
                return new PlaylistEntity
                {
                    Title = newPlaylist!.Title,
                    UniqueId = newPlaylist!.PlaylistId,
                    VideoCount = newPlaylist.VideoCount,

                    PlaylistThumbnail = newPlaylist.PlaylistThumbnail,
                    
                    Author = newPlaylist.Author,
                    AuthorId = newPlaylist.AuthorId,
                    AuthorUrl = newPlaylist.AuthorUrl,

                    AddedByUser = username,
                    DateLastScraped = null,
                    ScrapeFailureCount = 0
                };
            }).ToList();
            _videoDbContext.Playlists.AddRange(newPlaylistEntities);
            _videoDbContext.SaveChanges();//this should assign Ids to newPlaylistEntities
            await _meilisearchAccess.AddItems(newPlaylistEntities.Select(z => new MeilisearchItem
            {
                PlaylistId = z.Id,
                FilterPlaylistIds = [z.Id],
                Name = z.Title,
                SecondName = null
            }));
            var scheduler = await _schedulerFactory.GetScheduler();
            await scheduler.TriggerJob(JobKey.Create(nameof(PlaylistVideoJob)));
        }

        if (!request.AlgorithmId.HasValue)
        {
            _videoDbContext.Algorithms.Add(algorithm);
        }
        algorithm.Name = request.Name;
        algorithm.Description = request.Description;
        algorithm.MaxItemWeight = request.MaxItemWeight;
        algorithm.IsListed = request.IsListed;

        //remove all algorithmItems not found among request.AlgorithmItems
        var includedChannelIds = request.AlgorithmItems.Where(z => z.ChannelId.HasValue).Select(z => z.ChannelId).Distinct().ToList();
        var includedPlaylistIds = request.AlgorithmItems.Where(z => z.PlaylistId.HasValue).Select(z => z.PlaylistId).Distinct().ToList();
        if (algorithm.AlgorithmItems != null)
        {
            algorithm.AlgorithmItems = algorithm.AlgorithmItems
                .Where(z => includedPlaylistIds.Contains(z.PlaylistId) || includedChannelIds.Contains(z.ChannelId))
                .ToList();
        }
        else
        {
            algorithm.AlgorithmItems = new List<AlgorithmItemEntity>();
        }

        //update existing items' WeightMultiplier
        foreach (var existingItem in algorithm.AlgorithmItems)
        {
            if (existingItem.ChannelId.HasValue)
            {
                //we already removed the ones not present, so we can use First() rather than FirstOrDefault()
                var requestItem = request.AlgorithmItems.First(z => z.ChannelId == existingItem.ChannelId);
                existingItem.WeightMultiplier = requestItem.WeightMultiplier;
                existingItem.Folder = requestItem.Folder;
            }
            if (existingItem.PlaylistId.HasValue)
            {
                //we already removed the ones not present, so we can use First() rather than FirstOrDefault()
                var requestItem = request.AlgorithmItems.First(z => z.PlaylistId == existingItem.PlaylistId);
                existingItem.WeightMultiplier = requestItem.WeightMultiplier;
                existingItem.Folder = requestItem.Folder;
            }
        }

        //now start adding the new items
        //first add the newChannels
        var newChannelAlgorithmItems = request.AlgorithmItems.Where(z => z.NewChannel != null).Select(algorithmItem =>
        {
            var channelEntity = newChannelEntities.First(z => z.UniqueId == algorithmItem.NewChannel!.AuthorId);
            return new AlgorithmItemEntity
            {
                ChannelId = channelEntity.Id,
                WeightMultiplier = algorithmItem.WeightMultiplier,
            };
        }).ToList();
        //then add the channelIds
        newChannelAlgorithmItems.AddRange(request.AlgorithmItems
            .Where(z => z.ChannelId.HasValue && !algorithm.AlgorithmItems.Any(zz => zz.ChannelId == z.ChannelId))
            .Select(z => new AlgorithmItemEntity
            {
                ChannelId = z.ChannelId,
                WeightMultiplier = z.WeightMultiplier,
            }));
        foreach (var newItem in newChannelAlgorithmItems)
        {
            algorithm.AlgorithmItems.Add(newItem);
        }

        //now we'll do the same for playlists
        var newPlaylistAlgorithmItems = request.AlgorithmItems.Where(z => z.NewPlaylist != null).Select(algorithmItem =>
        {
            var playlistEntity = newPlaylistEntities.First(z => z.UniqueId == algorithmItem.NewPlaylist!.PlaylistId);
            return new AlgorithmItemEntity
            {
                PlaylistId = playlistEntity.Id,
                WeightMultiplier = algorithmItem.WeightMultiplier,
            };
        }).ToList();
        //then add the playlistIds
        newPlaylistAlgorithmItems.AddRange(request.AlgorithmItems
            .Where(z => z.PlaylistId.HasValue && !algorithm.AlgorithmItems.Any(zz => zz.PlaylistId == z.PlaylistId))
            .Select(z => new AlgorithmItemEntity
            {
                PlaylistId = z.PlaylistId,
                WeightMultiplier = z.WeightMultiplier,
            }));
        foreach (var newItem in newPlaylistAlgorithmItems)
        {
            algorithm.AlgorithmItems.Add(newItem);
        }

        _videoDbContext.SaveChanges();
        _globalCache.HandleAlgorithmUpdated(algorithm.Id);
        return algorithm.Id;
    }

    public void DeleteAlgorithm(int algorithmId, string username)
    {
        var algorithm = _videoDbContext.Algorithms.Include(z => z.AlgorithmItems).First(z => z.Id == algorithmId);
        if (algorithm.Username != username)
        {
            throw new WebRequestException(400, "Algorithm belongs to a different user");
        }
        _videoDbContext.Remove(algorithm);
        _videoDbContext.SaveChanges();
        _algorithmAccess.BustAlgorithmCache(algorithm.Username, algorithm.Name);
    }
}